#!/usr/bin/env node

import * as p from '@clack/prompts';
import pc from 'picocolors';
import { execSync, spawn } from 'child_process';
import { existsSync, readFileSync, writeFileSync, mkdirSync, readdirSync, lstatSync, readlinkSync } from 'fs';
import { homedir, platform } from 'os';
import { join, basename, resolve } from 'path';

const HOME = homedir();
const DOTFILES_DIR = resolve(join(import.meta.dirname, '..'));
const IS_MACOS = platform() === 'darwin';

// ============================================================================
// Helpers
// ============================================================================

function commandExists(cmd) {
  try {
    execSync(`command -v ${cmd}`, { stdio: 'ignore' });
    return true;
  } catch {
    return false;
  }
}

function getExistingGitConfig(key) {
  try {
    return execSync(`git config --global ${key}`, { stdio: 'pipe' }).toString().trim();
  } catch {
    return '';
  }
}

function getExistingGitConfigLocal() {
  const localFile = join(HOME, '.gitconfig.local');
  if (!existsSync(localFile)) return {};

  const content = readFileSync(localFile, 'utf-8');
  const result = {};
  const nameMatch = content.match(/name\s*=\s*(.+)/);
  const emailMatch = content.match(/email\s*=\s*(.+)/);
  if (nameMatch) result.name = nameMatch[1].trim();
  if (emailMatch) result.email = emailMatch[1].trim();
  return result;
}

function getComputerName() {
  if (!IS_MACOS) return '';
  try {
    return execSync('scutil --get ComputerName', { stdio: 'pipe' }).toString().trim();
  } catch {
    try {
      return execSync('hostname -s', { stdio: 'pipe' }).toString().trim();
    } catch {
      return '';
    }
  }
}

// ============================================================================
// Setup Modules
// ============================================================================

async function setupGitConfig() {
  // Read existing values: prefer .gitconfig.local, fall back to global git config
  const local = getExistingGitConfigLocal();
  const defaultName = local.name || getExistingGitConfig('user.name');
  const defaultEmail = local.email || getExistingGitConfig('user.email');

  const name = await p.text({
    message: 'Git user name',
    placeholder: 'Your Name',
    initialValue: defaultName,
    validate(value) {
      if (!value || value.trim().length === 0) return 'Name is required';
    },
  });

  if (p.isCancel(name)) {
    p.cancel('Setup cancelled');
    process.exit(0);
  }

  const email = await p.text({
    message: 'Git email',
    placeholder: 'you@example.com',
    initialValue: defaultEmail,
    validate(value) {
      if (!value || value.trim().length === 0) return 'Email is required';
      if (!value.includes('@')) return 'Enter a valid email';
    },
  });

  if (p.isCancel(email)) {
    p.cancel('Setup cancelled');
    process.exit(0);
  }

  const localFile = join(HOME, '.gitconfig.local');
  const content = `# Generated by dotfiles setup — not tracked in git
[user]
\tname = ${name}
\temail = ${email}
`;

  writeFileSync(localFile, content);
  p.log.success(`Wrote ${pc.dim('~/.gitconfig.local')}`);

  return { name, email };
}

async function setupComputerName() {
  if (!IS_MACOS) return null;

  const currentName = getComputerName();

  const name = await p.text({
    message: 'Computer name',
    placeholder: 'my-mac',
    initialValue: currentName,
    validate(value) {
      if (!value || value.trim().length === 0) return 'Name is required';
    },
  });

  if (p.isCancel(name)) {
    p.cancel('Setup cancelled');
    process.exit(0);
  }

  const isWork = await p.confirm({
    message: 'Is this a work machine?',
    initialValue: false,
  });

  if (p.isCancel(isWork)) {
    p.cancel('Setup cancelled');
    process.exit(0);
  }

  return { name, isWork };
}

async function runSymlinks() {
  const homeDir = join(DOTFILES_DIR, 'home');
  const backupDir = join(HOME, 'dotfiles_old');

  if (!existsSync(homeDir)) {
    p.log.warn(`No home/ directory found in ${DOTFILES_DIR}`);
    return;
  }

  const files = readdirSync(homeDir).filter(f => f.startsWith('.'));
  let created = 0;
  let skipped = 0;
  let backedUp = 0;

  for (const file of files) {
    const source = join(homeDir, file);
    const target = join(HOME, file);

    // Check if target exists (lstatSync doesn't follow symlinks, but throws if nothing exists)
    let targetExists = false;
    let targetStat = null;
    try {
      targetStat = lstatSync(target);
      targetExists = true;
    } catch {
      // Target doesn't exist — will create below
    }

    // Check if symlink already points to the correct target
    if (targetExists && targetStat.isSymbolicLink()) {
      try {
        const linkTarget = readlinkSync(target);
        if (resolve(linkTarget) === resolve(source)) {
          skipped++;
          continue;
        }
      } catch {
        // Can't read link — will back up below
      }
    }

    // Back up existing file/symlink
    if (targetExists) {
      mkdirSync(backupDir, { recursive: true });
      execSync(`mv "${target}" "${backupDir}/"`, { stdio: 'pipe' });
      backedUp++;
    }

    // Create symlink
    try {
      execSync(`ln -s "${source}" "${target}"`, { stdio: 'pipe' });
      created++;
    } catch (e) {
      p.log.warn(`Failed to link ${file}: ${e.message}`);
    }
  }

  const parts = [];
  if (created > 0) parts.push(`${created} created`);
  if (skipped > 0) parts.push(`${skipped} already correct`);
  if (backedUp > 0) parts.push(`${backedUp} backed up to ~/dotfiles_old`);

  if (parts.length > 0) {
    p.log.success(`Symlinks: ${parts.join(', ')}`);
  } else {
    p.log.info('No dotfiles found to link');
  }
}

async function runBrew() {
  const brewfile = join(DOTFILES_DIR, 'Brewfile');
  if (!existsSync(brewfile)) {
    p.log.warn('No Brewfile found');
    return;
  }

  if (!commandExists('brew')) {
    p.log.warn('Homebrew not available — skipping');
    return;
  }

  execSync(`brew bundle --file="${brewfile}"`, {
    stdio: 'inherit',
    cwd: DOTFILES_DIR,
  });
}

async function runNode() {
  const nodeScript = join(DOTFILES_DIR, 'node.sh');
  if (!existsSync(nodeScript)) {
    p.log.warn('No node.sh found');
    return;
  }

  execSync(`bash "${nodeScript}"`, {
    stdio: 'inherit',
    cwd: DOTFILES_DIR,
  });
}

async function runMacOS(computerName) {
  const macScript = join(DOTFILES_DIR, 'apply-macos-settings.sh');
  if (!existsSync(macScript)) {
    p.log.warn('No apply-macos-settings.sh found');
    return;
  }

  p.log.warn('This will modify macOS system settings and requires sudo.');

  const confirm = await p.confirm({
    message: 'Continue with macOS settings?',
    initialValue: true,
  });

  if (p.isCancel(confirm) || !confirm) {
    p.log.info('Skipped macOS settings');
    return;
  }

  const env = { ...process.env };
  if (computerName) {
    env.DOTFILES_COMPUTER_NAME = computerName.name;
    env.DOTFILES_WORK_MACHINE = computerName.isWork ? 'true' : 'false';
  }

  execSync(`bash "${macScript}"`, {
    stdio: 'inherit',
    cwd: DOTFILES_DIR,
    env,
  });
}

async function runNpmLogin() {
  p.log.info('Opening npm login (interactive browser auth)...');

  return new Promise((resolve) => {
    const child = spawn('npm', ['login'], {
      stdio: 'inherit',
      shell: true,
    });

    child.on('close', (code) => {
      if (code === 0) {
        p.log.success('npm login complete');
      } else {
        p.log.warn('npm login exited with errors');
      }
      resolve();
    });

    child.on('error', () => {
      p.log.warn('Could not run npm login');
      resolve();
    });
  });
}

// ============================================================================
// Main
// ============================================================================

async function main() {
  console.clear();
  p.intro(pc.cyan(pc.bold('  Dotfiles Setup  ')));

  // ── Git Configuration ─────────────────────────────────────────────────
  p.log.step(pc.bold('Git Configuration'));

  const gitConfig = await setupGitConfig();

  // ── Computer Name (macOS only) ────────────────────────────────────────
  let computerName = null;

  if (IS_MACOS) {
    p.log.step(pc.bold('Computer Name'));
    computerName = await setupComputerName();
  }

  // ── Module Selection ──────────────────────────────────────────────────
  const moduleOptions = [
    { value: 'symlinks', label: 'Symlink dotfiles to ~/', hint: 'home/ → ~/' },
    { value: 'brew', label: 'Install Homebrew packages', hint: 'Brewfile' },
    { value: 'node', label: 'Install Node.js via NVM + Bun', hint: 'node.sh' },
  ];

  if (IS_MACOS) {
    moduleOptions.push({
      value: 'macos',
      label: 'Apply macOS system settings',
      hint: 'requires sudo',
    });
  }

  moduleOptions.push({
    value: 'npm-login',
    label: 'Run npm login',
    hint: 'browser auth',
  });

  const modules = await p.multiselect({
    message: 'What would you like to set up?',
    options: moduleOptions,
    initialValues: ['symlinks', 'brew', 'node'],
    required: false,
  });

  if (p.isCancel(modules)) {
    p.cancel('Setup cancelled');
    process.exit(0);
  }

  // ── Execute Selected Modules ──────────────────────────────────────────

  if (modules.includes('symlinks')) {
    const s = p.spinner();
    s.start('Symlinking dotfiles');
    try {
      await runSymlinks();
      s.stop('Dotfiles symlinked');
    } catch (e) {
      s.stop('Symlinks failed');
      p.log.error(e.message);
    }
  }

  if (modules.includes('brew')) {
    p.log.step('Installing Homebrew packages...');
    try {
      await runBrew();
      p.log.success('Homebrew packages installed');
    } catch (e) {
      p.log.error(`Brew install failed: ${e.message}`);
    }
  }

  if (modules.includes('node')) {
    p.log.step('Installing Node.js, NVM, and Bun...');
    try {
      await runNode();
      p.log.success('Node.js environment installed');
    } catch (e) {
      p.log.error(`Node install failed: ${e.message}`);
    }
  }

  if (modules.includes('macos') && IS_MACOS) {
    try {
      await runMacOS(computerName);
      p.log.success('macOS settings applied');
    } catch (e) {
      p.log.error(`macOS settings failed: ${e.message}`);
    }
  }

  if (modules.includes('npm-login')) {
    try {
      await runNpmLogin();
    } catch (e) {
      p.log.error(`npm login failed: ${e.message}`);
    }
  }

  // ── Lacy Shell ────────────────────────────────────────────────────────
  p.log.step('Installing Lacy Shell...');
  try {
    execSync('npx -y lacy@latest', { stdio: 'inherit', cwd: DOTFILES_DIR });
    p.log.success('Lacy Shell installed');
  } catch (e) {
    p.log.error(`Lacy Shell install failed: ${e.message}`);
  }

  // ── Restart (macOS) ─────────────────────────────────────────────────
  if (IS_MACOS && modules.includes('macos')) {
    const restart = await p.confirm({
      message: 'Some macOS settings require a restart. Restart now?',
      initialValue: false,
    });

    if (!p.isCancel(restart) && restart) {
      p.outro('Restarting...');
      execSync('sudo shutdown -r now', { stdio: 'inherit' });
      return;
    }
  }

  // ── Done ──────────────────────────────────────────────────────────────
  p.outro(
    `Done! Run ${pc.cyan('source ~/.zshrc')} or restart your terminal.`
  );
}

main().catch((e) => {
  p.log.error(e.message);
  process.exit(1);
});
